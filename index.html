<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VOID Template Batch Renderer</title>
  <style>
    @font-face {
      font-family: 'ImpactBundled';
      src:
        url('./fonts/impact.woff2') format('woff2'),
        url('./fonts/impact.woff') format('woff'),
        url('./fonts/impact.ttf') format('truetype');
      font-style: normal;
      font-weight: 400;
      font-display: block;
    }
    :root {
      --bg-top:#f8efd9;
      --bg-mid:#f1e6ce;
      --bg-bot:#fbf7ef;
      --fg:#23180f;
      --muted:#6d5f52;
      --accent:#ffb700;
      --accent-strong:#ef9b1a;
      --card:#fff9efcc;
      --card-solid:#fff9ef;
      --bd:#d9c8ab;
      --ink:#362314;
      --danger:#8d3020;
    }
    * { box-sizing: border-box; }
    body {
      margin:0;
      font-family: "Avenir Next", "Trebuchet MS", "Helvetica Neue", sans-serif;
      color:var(--fg);
      background:
        radial-gradient(circle at 8% -5%, #ffe8af 0, transparent 34%),
        radial-gradient(circle at 90% 0%, #cde7f7 0, transparent 38%),
        linear-gradient(180deg, var(--bg-top) 0%, var(--bg-mid) 40%, var(--bg-bot) 100%);
      min-height: 100vh;
    }
    .wrap { max-width: 1240px; margin: 0 auto; padding: 18px 16px 28px; display: grid; gap: 14px; }
    .card {
      background:var(--card);
      border:1px solid var(--bd);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 18px 30px rgba(66, 45, 21, 0.07);
      backdrop-filter: blur(4px);
      animation: riseIn .36s ease both;
    }
    .card:nth-of-type(2) { animation-delay: .04s; }
    .card:nth-of-type(3) { animation-delay: .08s; }
    @keyframes riseIn {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .heroTop {
      display:grid;
      gap: 10px;
      justify-items: center;
      text-align: center;
    }
    .brand {
      font-family: ImpactBundled, "Arial Black", "Impact", sans-serif;
      letter-spacing: .8px;
      font-size: 30px;
      line-height: .95;
      text-transform: uppercase;
      color: var(--ink);
    }
    .heroInfo {
      margin-top: 7px;
      display: inline-flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 6px;
      max-width: 920px;
    }
    .sectionHead { display:grid; gap:4px; margin-bottom: 12px; }
    .sectionKicker {
      font-size: 12px;
      letter-spacing: 1.2px;
      text-transform: uppercase;
      color: var(--muted);
      font-weight: 700;
    }
    .sectionTitle { font-size: 20px; font-weight: 800; color: var(--ink); }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items: flex-end; }
    label { font-size: 13px; color: var(--muted); display:block; margin-bottom:6px; font-weight: 600; }
    input[type="text"], textarea {
      width: 360px; max-width: 100%;
      background:#fffcf7; color:var(--fg);
      border:1px solid #d8cbb7; border-radius: 12px;
      padding: 10px 12px; font-size: 15px; outline: none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.8);
    }
    input[type="text"]:focus, textarea:focus { border-color:#e0aa57; box-shadow: 0 0 0 3px rgba(255,183,0,.2); }
    textarea { height: 72px; resize: vertical; }
    #labelText { text-transform: uppercase; letter-spacing: .3px; }
    input[type="file"] { color: var(--muted); max-width: 360px; }
    input[type="range"] { width: 240px; accent-color: #d48f17; }
    button {
      background:#fff8ec; color:var(--ink);
      border:1px solid #d9c8ad; border-radius: 11px;
      padding: 10px 12px; cursor:pointer; font-weight: 760;
      user-select: none;
      transition: .18s ease;
    }
    button:hover:enabled { transform: translateY(-1px); border-color: #caa577; background:#fffdf6; }
    button.primary { background:linear-gradient(120deg, #ffd66f, #ffbf3f); border-color:#dba24a; }
    button.danger { background:#fff0ed; border-color:#e1b3ad; color: var(--danger); }
    button:disabled { opacity:.45; cursor:not-allowed; }
    .small { font-size: 13px; color: var(--muted); line-height: 1.35; }
    .pill {
      display:inline-block;
      padding:2px 8px;
      border:1px solid #dfccb1;
      border-radius: 999px;
      font-size: 13px;
      color: #70583a;
      background: #fff9ea;
    }
    .queueCta {
      background: linear-gradient(140deg, #d9f0ff, #b7dcf6 60%, #9cc9ed);
      border-color: #7eb1da;
      color: #10314b;
      box-shadow: 0 10px 20px rgba(47, 101, 145, 0.22);
      font-size: 15px;
      letter-spacing: .2px;
      padding: 11px 14px;
    }
    .queueCta:hover:enabled {
      background: linear-gradient(140deg, #e6f5ff, #c7e4fa 60%, #a9d2f1);
      border-color: #6ea3cf;
      box-shadow: 0 12px 22px rgba(47, 101, 145, 0.28);
    }
    .queueCtaWrap {
      display: flex;
      justify-content: center;
      margin-top: 8px;
      margin-bottom: 2px;
    }
    .queueCtaFrame {
      border: 3px solid #567f9d;
      border-radius: 16px;
      padding: 9px 12px;
      background: #eef7ff;
      box-shadow: 0 10px 18px rgba(26, 57, 82, 0.16);
    }
    .grid {
      display:grid;
      grid-template-columns: 1fr 350px;
      gap: 14px;
      align-items: start;
    }
    .canvasWrap { display:grid; gap:10px; }
    canvas {
      width: 100%;
      height: auto;
      background:#070707;
      border-radius: 12px;
      border:1px solid #bfa47f;
      touch-action: none;
      box-shadow: 0 8px 20px rgba(32, 20, 8, 0.2);
    }
    .queuePanel { display:grid; gap:10px; background:var(--card-solid); }
    .queueHeader { display:flex; align-items:center; justify-content: space-between; gap: 10px; }
    .queueList { display:grid; gap: 10px; max-height: 62vh; overflow: auto; padding-right: 2px; }
    .queueFooterActions {
      margin-top: 2px;
      display:flex;
      gap:10px;
      flex-wrap: wrap;
    }
    .queueFooterActions button {
      flex: 1 1 145px;
    }
    .qItem {
      display:grid;
      grid-template-columns: 72px 1fr;
      gap: 10px;
      padding: 10px;
      border:1px solid #dcc9ad;
      border-radius: 12px;
      background:#fffdf8;
    }
    .thumb {
      width: 72px; height: 72px;
      border-radius: 10px;
      border:1px solid #d9c8ae;
      object-fit: cover;
      background:#000;
      display:block;
    }
    .qMeta { display:grid; gap: 8px; }
    .qTitle { font-size: 14px; font-weight: 800; line-height: 1.2; color: var(--ink); }
    .qSub { font-size: 13px; color: var(--muted); line-height: 1.25; }
    .qActions { display:flex; gap: 8px; flex-wrap: wrap; }
    code { color:#7f5600; }
    @media (max-width: 980px) {
      .grid { grid-template-columns: 1fr; }
      .brand { font-size: 24px; }
      .queueList { max-height: none; }
      .queueCtaFrame { width: min(420px, 100%); }
      .queueCtaFrame button { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="heroTop">
        <div>
          <div class="brand">VOID Template Batch Renderer</div>
          <div class="small heroInfo">
            Output: <span class="pill">1080 × 1350</span>
            Text: <span class="pill">Impact</span> <span class="pill">ALL CAPS</span> <span class="pill">#FFB700</span>
            Template file: <span class="pill">VOID_IG_TEMPLATE.png</span>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="sectionHead">
        <div class="sectionKicker">Step 1</div>
        <div class="sectionTitle">Load Images and Set Navigation</div>
      </div>
      <div class="row">
        <div>
          <label>Batch images</label>
          <input id="images" type="file" accept="image/*" multiple />
          <div class="small">Pick all source photos. Queueing auto-advances through the set.</div>
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="sectionHead">
          <div class="sectionKicker">Step 2</div>
          <div class="sectionTitle">Compose and Queue</div>
        </div>
        <div class="row" style="align-items:flex-start;">
          <div style="min-width: 280px;">
            <label>Current image</label>
            <div id="currentLabel" class="small">None loaded</div>
          </div>

          <div>
            <label>Text (newline = 2 lines)</label>
            <textarea id="labelText" placeholder="SWITCHBLADE&#10;TATTOO CLUB"></textarea>
          </div>

          <div>
            <label>Zoom</label>
            <input id="zoom" type="range" min="0.5" max="3.5" value="1.0" step="0.01" />
            <div class="small">Drag to position. On touch: pinch to zoom and twist to rotate.</div>
          </div>

          <div>
            <label>Text size cap</label>
            <input id="textSize" type="range" min="48" max="320" value="220" step="1" />
            <div class="small"><span id="textSizeVal">220</span> px</div>
          </div>

          <div>
            <label>Text vertical offset</label>
            <input id="textOffset" type="range" min="-120" max="180" value="0" step="1" />
            <div class="small"><span id="textOffsetVal">0</span> px</div>
          </div>

          <div>
            <label>Line spacing</label>
            <input id="lineGap" type="range" min="0.4" max="2.4" value="1.0" step="0.05" />
            <div class="small"><span id="lineGapVal">1.00</span>x</div>
          </div>

        </div>

        <div class="canvasWrap" style="margin-top:12px;">
          <canvas id="preview" width="1080" height="1350"></canvas>
          <div class="queueCtaWrap">
            <div class="queueCtaFrame">
              <button id="queueBtn" class="queueCta" disabled>ADD TO QUEUE (AUTO-NEXT)</button>
            </div>
          </div>
          <div class="small">Preview matches export exactly (1080×1350). Reposition by dragging inside the image window.</div>
          <div class="small" id="status"></div>
        </div>
      </div>

      <div class="card queuePanel">
        <div class="sectionHead">
          <div class="sectionKicker">Step 3 / 4</div>
          <div class="sectionTitle">Review Queue and Save</div>
        </div>
        <div class="queueHeader">
          <div class="small">Queue: <span id="queueCount" class="pill">0</span></div>
          <div class="row" style="gap:8px;">
            <button id="clearQueueBtn" class="danger" disabled>Clear</button>
          </div>
        </div>
        <div id="queueList" class="queueList"></div>
        <div class="small">Edit reopens that queued item’s settings. Remove deletes it from the ZIP.</div>
        <div class="queueFooterActions">
          <button id="savePhotosBtn" disabled>Save to Photos</button>
          <button id="exportZipBtn" class="primary" disabled>Export ZIP</button>
        </div>
      </div>
    </div>
  </div>

  <!-- JSZip + FileSaver -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <script>
    // Fixed export size (recommended)
    const EXPORT_W = 1080;
    const EXPORT_H = 1350;

    // Template is 1638x2048 (native). Export keeps same aspect ratio.
    const TEMPLATE_SRC = 'VOID_IG_TEMPLATE.png';
    const SCALE = EXPORT_W / 1638;

    // Frame bbox in native template coords (from your template)
    const FRAME_NATIVE = { x: 399, y: 466, w: (1242-399+1), h: (1364-466+1) };
    const BAR_NATIVE_Y = 1441;

    const FRAME = {
      x: FRAME_NATIVE.x * SCALE,
      y: FRAME_NATIVE.y * SCALE,
      w: FRAME_NATIVE.w * SCALE,
      h: FRAME_NATIVE.h * SCALE
    };

    const BAR = {
      y: BAR_NATIVE_Y * SCALE,
      h: EXPORT_H - (BAR_NATIVE_Y * SCALE)
    };
    const LABEL_PADDING_X = 40;
    const LABEL_PADDING_Y = 10;
    const LABEL_GAP_RATIO = 0.16;

    const state = {
      templateImg: null,

      // source images (files)
      images: [],
      currentIndex: -1,
      currentImgEl: null,

      // current edit settings
      offsetX: 0,
      offsetY: 0,
      scale: 1,
      rotation: 0,

      dragging: false,
      dragStart: null,
      activePointers: new Map(),
      pinchGesture: null,
      labelZoneTop: BAR.y,
      labelZoneBottom: EXPORT_H,

      // bundled Impact font
      impactFontReady: false,

      // queue items: { id, sourceIndex, sourceName, sourceThumbUrl, imgEl, settings, filename, blob, text }
      queue: [],
      nextId: 1
    };

    const el = (id) => document.getElementById(id);

    const preview = el('preview');
    const ctx = preview.getContext('2d');

    const imagesInput = el('images');
    const prevBtn = el('prevBtn');
    const nextBtn = el('nextBtn');
    const queueBtn = el('queueBtn');
    const savePhotosBtn = el('savePhotosBtn');
    const exportZipBtn = el('exportZipBtn');
    const clearQueueBtn = el('clearQueueBtn');

    const zoomInput = el('zoom');
    const ZOOM_MIN = parseFloat(zoomInput.min) || 0.5;
    const ZOOM_MAX = parseFloat(zoomInput.max) || 3.5;
    const labelText = el('labelText');
    const textSize = el('textSize');
    const textSizeVal = el('textSizeVal');
    const textOffset = el('textOffset');
    const textOffsetVal = el('textOffsetVal');
    const lineGap = el('lineGap');
    const lineGapVal = el('lineGapVal');

    const currentLabelEl = el('currentLabel');
    const statusEl = el('status');
    const queueCountEl = el('queueCount');
    const queueListEl = el('queueList');

    function setStatus(msg) { statusEl.textContent = msg || ''; }
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    function getTextOffsetY() { return clamp(parseInt(textOffset.value, 10) || 0, -120, 180); }
    function getLineGapMult() { return clamp(parseFloat(lineGap.value) || 1, 0.4, 2.4); }

    function getFontFamily() {
      return 'ImpactBundled';
    }

    async function ensureImpactFontLoaded() {
      try {
        await document.fonts.load(`120px ${getFontFamily()}`);
        state.impactFontReady = document.fonts.check(`120px ${getFontFamily()}`);
        return state.impactFontReady;
      } catch {
        state.impactFontReady = false;
        return false;
      }
    }

    function requireImpactFontLoaded() {
      if (!state.impactFontReady) {
        state.impactFontReady = document.fonts.check(`120px ${getFontFamily()}`);
      }
      if (state.impactFontReady) return;
      throw new Error('Impact font not loaded. Add licensed font at fonts/impact.ttf (or .woff2/.woff).');
    }

    function queueItemToFile(item) {
      return new File([item.blob], item.filename, { type: 'image/png' });
    }

    function canShareFiles(files) {
      if (!navigator.share || !navigator.canShare) return false;
      try {
        return navigator.canShare({ files });
      } catch {
        return false;
      }
    }

    function defaultCoverScale(img) {
      // cover the frame (like background-size: cover)
      const sx = FRAME.w / img.naturalWidth;
      const sy = FRAME.h / img.naturalHeight;
      return Math.max(sx, sy);
    }

    function detectBottomBarTop() {
      if (!state.templateImg) return BAR.y;
      const c = document.createElement('canvas');
      c.width = EXPORT_W;
      c.height = EXPORT_H;
      const cctx = c.getContext('2d', { willReadFrequently: true });
      cctx.drawImage(state.templateImg, 0, 0, EXPORT_W, EXPORT_H);
      const data = cctx.getImageData(0, 0, EXPORT_W, EXPORT_H).data;

      const xStart = Math.floor(EXPORT_W * 0.04);
      const xEnd = Math.ceil(EXPORT_W * 0.96);
      const yStart = Math.floor(EXPORT_H * 0.55);
      const sampleStep = 2;
      let run = 0;
      let detected = -1;

      for (let y = yStart; y < EXPORT_H; y++) {
        let dark = 0;
        let total = 0;
        for (let x = xStart; x < xEnd; x += sampleStep) {
          const i = ((y * EXPORT_W) + x) * 4;
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const a = data[i + 3];
          total++;
          if (a > 220 && r < 22 && g < 22 && b < 22) dark++;
        }
        const ratio = total ? (dark / total) : 0;
        if (ratio >= 0.9) {
          run++;
          if (run >= 8) {
            detected = y - run + 1;
            break;
          }
        } else {
          run = 0;
        }
      }

      if (detected < 0) return BAR.y;
      return clamp(detected, BAR.y - 120, BAR.y + 220);
    }

    function syncLabelZoneFromTemplate() {
      state.labelZoneTop = detectBottomBarTop();
      state.labelZoneBottom = EXPORT_H;
    }

    async function loadTemplate() {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Failed to load template image. Ensure VOID_IG_TEMPLATE.png is next to index.html'));
        img.src = TEMPLATE_SRC;
      });
    }

    async function loadFileImage(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Failed to load image: ' + file.name)); };
        img.src = url;
      });
    }

    function normalizeLines(text) {
      const cleaned = (text || '').split('\n').map(s => s.trim()).filter(Boolean);
      if (cleaned.length <= 2) return cleaned.map(s => s.toUpperCase());
      const first = cleaned[0];
      const rest = cleaned.slice(1).join(' ');
      return [first.toUpperCase(), rest.toUpperCase()];
    }

    function measureLineMetrics(targetCtx, line, size) {
      targetCtx.font = `${size}px ${getFontFamily()}`;
      const m = targetCtx.measureText(line);
      const ascent = m.actualBoundingBoxAscent || (size * 0.78);
      const descent = m.actualBoundingBoxDescent || (size * 0.22);
      return {
        width: m.width,
        ascent,
        descent,
        height: ascent + descent
      };
    }

    function computeSmartLabelLayout(targetCtx, text, requestedMaxSize, lineGapMult) {
      const lines = normalizeLines(text);
      if (!lines.length) return null;

      const maxWidth = EXPORT_W - (LABEL_PADDING_X * 2);
      const zoneTop = state.labelZoneTop ?? BAR.y;
      const zoneBottom = state.labelZoneBottom ?? EXPORT_H;
      const maxHeight = Math.max(20, (zoneBottom - zoneTop) - (LABEL_PADDING_Y * 2));
      const minSize = 8;
      const cap = clamp(Math.round(requestedMaxSize || 220), minSize, 420);
      const gapRatio = LABEL_GAP_RATIO * clamp(lineGapMult || 1, 0.4, 2.4);

      let low = minSize;
      let high = cap;
      let best = minSize;
      let bestMetrics = [];
      let bestGap = minSize * gapRatio;
      let bestTotalH = 0;

      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        const gap = mid * gapRatio;
        const metrics = lines.map(ln => measureLineMetrics(targetCtx, ln, mid));
        const totalH = metrics.reduce((sum, mt) => sum + mt.height, 0) + ((lines.length - 1) * gap);
        const maxLineW = Math.max(...metrics.map(mt => mt.width));
        if (totalH <= maxHeight && maxLineW <= maxWidth) {
          best = mid;
          bestMetrics = metrics;
          bestGap = gap;
          bestTotalH = totalH;
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }

      if (!bestMetrics.length) {
        bestMetrics = lines.map(ln => measureLineMetrics(targetCtx, ln, best));
        bestGap = best * gapRatio;
        bestTotalH = bestMetrics.reduce((sum, mt) => sum + mt.height, 0) + ((lines.length - 1) * bestGap);
      }
      return { lines, size: best, gap: bestGap, totalH: bestTotalH, metrics: bestMetrics };
    }

    function drawLabel(targetCtx, text, requestedMaxSize, textOffsetY, lineGapMult) {
      const raw = (text || '').trim();
      if (!raw || !state.impactFontReady) return;
      const layout = computeSmartLabelLayout(targetCtx, raw, requestedMaxSize, lineGapMult);
      if (!layout) return;

      const cx = EXPORT_W / 2;
      const zoneTop = (state.labelZoneTop ?? BAR.y) + LABEL_PADDING_Y;
      const zoneBottom = (state.labelZoneBottom ?? EXPORT_H) - LABEL_PADDING_Y;
      const zoneCenterY = ((zoneTop + zoneBottom) / 2) + (textOffsetY || 0);

      targetCtx.save();
      targetCtx.fillStyle = '#FFB700';
      targetCtx.textAlign = 'center';
      targetCtx.textBaseline = 'alphabetic';
      targetCtx.font = `${layout.size}px ${getFontFamily()}`;

      let top = zoneCenterY - (layout.totalH / 2);
      for (let i = 0; i < layout.lines.length; i++) {
        const lineMetrics = layout.metrics[i];
        const baselineY = top + lineMetrics.ascent;
        targetCtx.fillText(layout.lines[i], cx, baselineY);
        top += lineMetrics.height + layout.gap;
      }
      targetCtx.restore();
    }

    function drawImageInFrame(targetCtx, imgEl, settings) {
      if (!imgEl) return;
      targetCtx.save();
      targetCtx.beginPath();
      targetCtx.rect(FRAME.x, FRAME.y, FRAME.w, FRAME.h);
      targetCtx.clip();

      const base = defaultCoverScale(imgEl);
      const finalScale = base * settings.scale;
      const drawW = imgEl.naturalWidth * finalScale;
      const drawH = imgEl.naturalHeight * finalScale;
      const frameCx = FRAME.x + FRAME.w / 2;
      const frameCy = FRAME.y + FRAME.h / 2;

      targetCtx.translate(frameCx + settings.offsetX, frameCy + settings.offsetY);
      targetCtx.rotate(settings.rotation || 0);
      targetCtx.drawImage(imgEl, -drawW / 2, -drawH / 2, drawW, drawH);
      targetCtx.restore();
    }

    function drawComposed(targetCtx, imgEl, settings, text, fontPx) {
      targetCtx.clearRect(0, 0, EXPORT_W, EXPORT_H);
      targetCtx.drawImage(state.templateImg, 0, 0, EXPORT_W, EXPORT_H);
      if (imgEl) {
        drawImageInFrame(targetCtx, imgEl, settings);
      }
      targetCtx.drawImage(state.templateImg, 0, 0, EXPORT_W, EXPORT_H);
      drawLabel(
        targetCtx,
        text,
        fontPx ?? settings.textSize,
        settings.textOffsetY ?? 0,
        settings.lineGapMult ?? 1
      );
    }

    function renderWithSettings(imgEl, settings, text, fontPx) {
      drawComposed(ctx, imgEl, settings, text, fontPx);
    }

    function renderPreview() {
      if (!state.templateImg) return;
      const settings = {
        offsetX: state.offsetX,
        offsetY: state.offsetY,
        scale: state.scale,
        rotation: state.rotation,
        textSize: clamp(parseInt(textSize.value, 10) || 220, 48, 320),
        textOffsetY: getTextOffsetY(),
        lineGapMult: getLineGapMult()
      };
      renderWithSettings(state.currentImgEl, settings, labelText.value);
    }

    function updateUI() {
      if (!state.impactFontReady) {
        state.impactFontReady = document.fonts.check(`120px ${getFontFamily()}`);
      }
      const hasImages = state.images.length > 0;
      const hasCurrent = !!state.currentImgEl;
      const hasQueue = state.queue.length > 0;
      if (prevBtn) prevBtn.disabled = !(hasImages && state.currentIndex > 0);
      if (nextBtn) nextBtn.disabled = !(hasImages && state.currentIndex < state.images.length - 1);
      queueBtn.disabled = !(hasCurrent && state.impactFontReady);
      savePhotosBtn.disabled = !hasQueue;

      exportZipBtn.disabled = !hasQueue;
      clearQueueBtn.disabled = !hasQueue;
      queueBtn.textContent = state._editingId ? 'Update queued item' : 'ADD TO QUEUE (AUTO-NEXT)';

      if (!hasImages) currentLabelEl.textContent = 'None loaded';
      else currentLabelEl.textContent = `${state.currentIndex + 1}/${state.images.length}: ${state.images[state.currentIndex].name}`;

      queueCountEl.textContent = String(state.queue.length);
      textSizeVal.textContent = textSize.value;
      textOffsetVal.textContent = textOffset.value;
      lineGapVal.textContent = Number(lineGap.value).toFixed(2);

      renderQueueList();
    }

    async function setCurrentIndex(i) {
      state.currentIndex = i;
      setStatus('Loading image…');
      const file = state.images[i];
      state.currentImgEl = await loadFileImage(file);

      // reset transform
      state.offsetX = 0;
      state.offsetY = 0;
      state.scale = 1;
      state.rotation = 0;
      state.dragging = false;
      state.dragStart = null;
      state.activePointers.clear();
      state.pinchGesture = null;
      zoomInput.value = '1.0';

      setStatus('');
      updateUI();
      renderPreview();
    }

    function slugify(s) {
      return (s || '')
        .trim()
        .toLowerCase()
        .replace(/[\n\r\t]+/g, ' ')
        .replace(/[^a-z0-9]+/g,'-')
        .replace(/(^-|-$)/g,'')
        .slice(0, 80) || 'output';
    }

    function stripExtension(name) {
      return String(name || '').replace(/\.[^.]+$/, '');
    }

    function makeBaseNameFromText(text, fallbackName) {
      const textFlat = String(text || '').replace(/\s+/g, ' ').trim();
      const fallback = stripExtension(fallbackName || 'output');
      return slugify(textFlat || fallback);
    }

    function makeUniqueFilename(baseName, editingId) {
      const used = new Set(
        state.queue
          .filter(item => item.id !== editingId)
          .map(item => String(item.filename || '').toLowerCase())
      );
      let n = 0;
      while (true) {
        const candidate = n === 0 ? `${baseName}.png` : `${baseName}-${n}.png`;
        if (!used.has(candidate.toLowerCase())) return candidate;
        n++;
      }
    }

    async function makeThumbBlob(imgEl, settings, text) {
      requireImpactFontLoaded();
      const c = document.createElement('canvas');
      c.width = 360;
      c.height = 450;
      const cctx = c.getContext('2d');

      // draw full export to offscreen then scale down for thumb
      const full = document.createElement('canvas');
      full.width = EXPORT_W;
      full.height = EXPORT_H;
      const fctx = full.getContext('2d');

      drawComposed(fctx, imgEl, settings, text, settings.textSize);

      // scale to thumb
      cctx.drawImage(full, 0, 0, c.width, c.height);

      const blob = await new Promise(res => c.toBlob(res, 'image/jpeg', 0.88));
      return blob;
    }

    async function renderExportBlob(imgEl, settings, text) {
      requireImpactFontLoaded();
      const c = document.createElement('canvas');
      c.width = EXPORT_W;
      c.height = EXPORT_H;
      const cctx = c.getContext('2d');

      drawComposed(cctx, imgEl, settings, text, settings.textSize);

      const blob = await new Promise(res => c.toBlob(res, 'image/png'));
      return blob;
    }

    function renderQueueList() {
      queueListEl.innerHTML = '';

      if (state.queue.length === 0) {
        const d = document.createElement('div');
        d.className = 'small';
        d.textContent = 'No queued items yet.';
        queueListEl.appendChild(d);
        return;
      }

      for (const item of state.queue) {
        const wrap = document.createElement('div');
        wrap.className = 'qItem';

        const img = document.createElement('img');
        img.className = 'thumb';
        img.src = item.thumbUrl;
        img.alt = item.textOneLine || item.filename;

        const meta = document.createElement('div');
        meta.className = 'qMeta';

        const title = document.createElement('div');
        title.className = 'qTitle';
        title.textContent = item.textOneLine || '(no text)';

        const sub = document.createElement('div');
        sub.className = 'qSub';
        sub.textContent = `${item.filename} • source: ${item.sourceName}`;

        const actions = document.createElement('div');
        actions.className = 'qActions';

        const editBtn = document.createElement('button');
        editBtn.textContent = 'Edit';
        editBtn.addEventListener('click', async () => {
          // Load that item into editor without removing it
          state.currentIndex = item.sourceIndex;
          state.currentImgEl = item.imgEl;

          state.offsetX = item.settings.offsetX;
          state.offsetY = item.settings.offsetY;
          state.scale = item.settings.scale;
          state.rotation = item.settings.rotation || 0;

          zoomInput.value = String(state.scale);
          textSize.value = String(item.settings.textSize || 220);
          textOffset.value = String(item.settings.textOffsetY || 0);
          lineGap.value = String(item.settings.lineGapMult || 1);
          labelText.value = item.text;

          // mark as "editing existing"
          state._editingId = item.id;

          setStatus(`Editing queued item: ${item.filename}`);
          updateUI();
          renderPreview();
        });

        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.className = 'danger';
        removeBtn.addEventListener('click', () => {
          // revoke thumb url
          try { URL.revokeObjectURL(item.thumbUrl); } catch {}
          state.queue = state.queue.filter(q => q.id !== item.id);
          if (state._editingId === item.id) {
            state._editingId = null;
            setStatus('');
          }
          updateUI();
        });

        actions.appendChild(editBtn);
        actions.appendChild(removeBtn);

        meta.appendChild(title);
        meta.appendChild(sub);
        meta.appendChild(actions);

        wrap.appendChild(img);
        wrap.appendChild(meta);
        queueListEl.appendChild(wrap);
      }
    }

    function pointerPos(evt) {
      const rect = preview.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (preview.width / rect.width);
      const y = (evt.clientY - rect.top) * (preview.height / rect.height);
      return { x, y };
    }

    function isInFrame(pos) {
      return pos.x >= FRAME.x && pos.x <= FRAME.x + FRAME.w && pos.y >= FRAME.y && pos.y <= FRAME.y + FRAME.h;
    }

    function pointerDistance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function pointerAngle(a, b) {
      return Math.atan2(b.y - a.y, b.x - a.x);
    }

    function angleDelta(current, start) {
      let d = current - start;
      while (d > Math.PI) d -= Math.PI * 2;
      while (d < -Math.PI) d += Math.PI * 2;
      return d;
    }

    // Events
    textSize.addEventListener('input', () => {
      textSizeVal.textContent = textSize.value;
      renderPreview();
    });
    textOffset.addEventListener('input', () => {
      textOffsetVal.textContent = textOffset.value;
      renderPreview();
    });
    lineGap.addEventListener('input', () => {
      lineGapVal.textContent = Number(lineGap.value).toFixed(2);
      renderPreview();
    });
    zoomInput.addEventListener('input', () => {
      state.scale = clamp(parseFloat(zoomInput.value), ZOOM_MIN, ZOOM_MAX);
      renderPreview();
    });
    labelText.addEventListener('input', renderPreview);

    preview.addEventListener('pointerdown', (e) => {
      if (!state.currentImgEl) return;
      const p = pointerPos(e);
      if (!isInFrame(p)) return;
      state.activePointers.set(e.pointerId, p);
      if (state.activePointers.size === 1) {
        state.dragging = true;
        state.dragStart = { pointerId: e.pointerId, x: p.x, y: p.y, ox: state.offsetX, oy: state.offsetY };
      } else if (state.activePointers.size === 2) {
        const [a, b] = Array.from(state.activePointers.values());
        state.dragging = false;
        state.dragStart = null;
        state.pinchGesture = {
          distance: pointerDistance(a, b),
          angle: pointerAngle(a, b),
          startScale: state.scale,
          startRotation: state.rotation
        };
      }
      preview.setPointerCapture(e.pointerId);
    });

    preview.addEventListener('pointermove', (e) => {
      const p = pointerPos(e);
      if (state.activePointers.has(e.pointerId)) {
        state.activePointers.set(e.pointerId, p);
      }

      if (state.activePointers.size >= 2 && state.pinchGesture) {
        const [a, b] = Array.from(state.activePointers.values());
        const dist = pointerDistance(a, b);
        const ang = pointerAngle(a, b);
        const scaleMul = state.pinchGesture.distance > 0 ? (dist / state.pinchGesture.distance) : 1;
        state.scale = clamp(state.pinchGesture.startScale * scaleMul, ZOOM_MIN, ZOOM_MAX);
        state.rotation = state.pinchGesture.startRotation + angleDelta(ang, state.pinchGesture.angle);
        zoomInput.value = state.scale.toFixed(2);
        renderPreview();
        return;
      }

      if (state.dragging && state.dragStart && state.dragStart.pointerId === e.pointerId) {
        const dx = p.x - state.dragStart.x;
        const dy = p.y - state.dragStart.y;
        state.offsetX = state.dragStart.ox + dx;
        state.offsetY = state.dragStart.oy + dy;
        renderPreview();
      }
    });

    function endPointer(e) {
      state.activePointers.delete(e.pointerId);
      if (state.dragStart && state.dragStart.pointerId === e.pointerId) {
        state.dragging = false;
        state.dragStart = null;
      }
      if (state.activePointers.size < 2) {
        state.pinchGesture = null;
      }
      try { preview.releasePointerCapture(e.pointerId); } catch {}
    }

    preview.addEventListener('pointerup', endPointer);
    preview.addEventListener('pointercancel', endPointer);
    preview.addEventListener('pointerleave', endPointer);

    if (prevBtn) {
      prevBtn.addEventListener('click', async () => {
        if (state.currentIndex > 0) {
          state._editingId = null;
          setStatus('');
          await setCurrentIndex(state.currentIndex - 1);
        }
      });
    }

    if (nextBtn) {
      nextBtn.addEventListener('click', async () => {
        if (state.currentIndex < state.images.length - 1) {
          state._editingId = null;
          setStatus('');
          await setCurrentIndex(state.currentIndex + 1);
        }
      });
    }

    imagesInput.addEventListener('change', async (e) => {
      try {
        if (!state.templateImg) {
          state.templateImg = await loadTemplate();
          syncLabelZoneFromTemplate();
        }

        const files = Array.from(e.target.files || []).filter(f => f.type.startsWith('image/'));
        state.images = files;
        state.queue.forEach(q => { try { URL.revokeObjectURL(q.thumbUrl); } catch {} });
        state.queue = [];
        state._editingId = null;

        labelText.value = '';
        zoomInput.value = '1.0';
        textSize.value = '220';
        textSizeVal.textContent = '220';
        textOffset.value = '0';
        textOffsetVal.textContent = '0';
        lineGap.value = '1.0';
        lineGapVal.textContent = '1.00';

        if (files.length) {
          await setCurrentIndex(0);
        } else {
          state.currentIndex = -1;
          state.currentImgEl = null;
          currentLabelEl.textContent = 'None loaded';
          renderPreview();
        }

        updateUI();
      } catch (err) {
        setStatus(err.message);
      }
    });

    queueBtn.addEventListener('click', async () => {
      if (!state.currentImgEl) return;

      const text = labelText.value || '';
      const settings = {
        offsetX: state.offsetX,
        offsetY: state.offsetY,
        scale: state.scale,
        rotation: state.rotation,
        textSize: clamp(parseInt(textSize.value, 10) || 220, 48, 320),
        textOffsetY: getTextOffsetY(),
        lineGapMult: getLineGapMult()
      };

      // If editing an existing queued item, update it in place.
      const editingId = state._editingId || null;

      try {
        requireImpactFontLoaded();
        setStatus(editingId ? 'Updating queued item…' : 'Queueing…');

        const blob = await renderExportBlob(state.currentImgEl, settings, text);

        const firstLine = (text || '').split('\n')[0].trim();
        const sourceFallbackName = state.images[state.currentIndex]?.name || 'output';
        const baseName = makeBaseNameFromText(text, sourceFallbackName);
        const filename = makeUniqueFilename(baseName, editingId);

        // thumb
        const thumbBlob = await makeThumbBlob(state.currentImgEl, settings, text);
        const thumbUrl = URL.createObjectURL(thumbBlob);

        if (editingId) {
          const idx = state.queue.findIndex(q => q.id === editingId);
          if (idx !== -1) {
            // revoke old thumb
            try { URL.revokeObjectURL(state.queue[idx].thumbUrl); } catch {}
            state.queue[idx] = {
              ...state.queue[idx],
              sourceIndex: state.currentIndex,
              sourceName: state.images[state.currentIndex]?.name || state.queue[idx].sourceName,
              imgEl: state.currentImgEl,
              settings,
              text,
              textOneLine: firstLine.toUpperCase(),
              filename,
              blob,
              thumbUrl
            };
          }
          state._editingId = null;
          setStatus('Updated. Auto-advancing…');
        } else {
          state.queue.push({
            id: state.nextId++,
            sourceIndex: state.currentIndex,
            sourceName: state.images[state.currentIndex].name,
            imgEl: state.currentImgEl,
            settings,
            text,
            textOneLine: firstLine.toUpperCase(),
            filename,
            blob,
            thumbUrl
          });
          setStatus('Queued. Auto-advancing…');
        }

        updateUI();
        setTimeout(() => setStatus(''), 700);

        // Auto-advance to next image if possible
        if (state.images.length && state.currentIndex < state.images.length - 1) {
          await setCurrentIndex(state.currentIndex + 1);
        } else {
          // stay on last, but keep preview
          renderPreview();
        }
      } catch (err) {
        setStatus(err?.message || 'Failed to render this item.');
      }
    });

    exportZipBtn.addEventListener('click', async () => {
      if (state.queue.length === 0) return;

      setStatus('Building ZIP…');
      const zip = new JSZip();

      // keep deterministic order: by queue order
      for (const item of state.queue) {
        zip.file(item.filename, item.blob);
      }

      const out = await zip.generateAsync({ type: 'blob' });
      saveAs(out, 'void-exports.zip');
      setStatus('');
    });

    savePhotosBtn.addEventListener('click', async () => {
      if (state.queue.length === 0) return;

      try {
        const allFiles = state.queue.map(queueItemToFile);
        if (canShareFiles(allFiles)) {
          setStatus('Opening share sheet… Choose Save Image/Add to Photos.');
          await navigator.share({ files: allFiles, title: 'VOID exports' });
          setStatus('Share complete.');
          setTimeout(() => setStatus(''), 1200);
          return;
        }

        // Some browsers only allow one file at a time.
        if (navigator.share) {
          const shareable = state.queue.filter(item => canShareFiles([queueItemToFile(item)]));
          if (shareable.length > 0) {
            setStatus('Sharing one image at a time… Use Save Image/Add to Photos for each one.');
            for (const item of shareable) {
              const file = queueItemToFile(item);
              await navigator.share({ files: [file], title: item.filename });
              await delay(120);
            }
            setStatus('All share sheets shown.');
            setTimeout(() => setStatus(''), 1200);
            return;
          }
        }

        // Fallback: download PNG files.
        setStatus('File sharing is not supported here. Downloading PNG files instead.');
        for (const item of state.queue) {
          const url = URL.createObjectURL(item.blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = item.filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          await delay(80);
        }
        setStatus('Download complete.');
        setTimeout(() => setStatus(''), 1200);
      } catch (err) {
        if (err?.name === 'AbortError') {
          setStatus('Share canceled.');
          setTimeout(() => setStatus(''), 1200);
          return;
        }
        setStatus('Could not share images. Use Export ZIP as fallback.');
      }
    });

    clearQueueBtn.addEventListener('click', () => {
      state.queue.forEach(q => { try { URL.revokeObjectURL(q.thumbUrl); } catch {} });
      state.queue = [];
      state._editingId = null;
      setStatus('');
      updateUI();
    });

    // Init
    (async function init() {
      try {
        const impactReady = await ensureImpactFontLoaded();
        state.templateImg = await loadTemplate();
        syncLabelZoneFromTemplate();
        renderPreview();
        updateUI();
        if (!impactReady) {
          setStatus('Impact font missing. Add licensed font at fonts/impact.ttf (or .woff2/.woff).');
        }
      } catch (err) {
        setStatus(err.message);
      }
    })();
  </script>
</body>
</html>
